I"ú<p>This is an experiment in converting video files in the browser. It works by displaying a video frame by frame on a canvas and then append the canvasâ€™ contents to a GIF.</p>

<h2 id="features">Features</h2>

<ul>
  <li>Convert video files to <code class="language-plaintext highlighter-rouge">.gif</code> files directly in your browser</li>
  <li>Supports <code class="language-plaintext highlighter-rouge">.mov</code>, <code class="language-plaintext highlighter-rouge">.mp4</code>, <code class="language-plaintext highlighter-rouge">.webm</code> or <strong>any other video format</strong> thatâ€™s supported by the HTML5 <code class="language-plaintext highlighter-rouge">&lt;video&gt;</code> tag</li>
  <li>Trim the GIF to desired length</li>
  <li>Since everything is done in the browser, nothing is ever sent to a server and your privacy is protected</li>
</ul>

<h3 id="planned">Planned</h3>

<ul>
  <li>Resizing</li>
</ul>

<h2 id="how-it-works">How it works</h2>

<p>When I started, I wanted to find out what the capabilities of <a href="https://webassembly.org">Web Assembly</a> were. However, at that time, there wasnâ€™t much support for it out there. I tried to compile <a href="https://ffmpeg.org">FFMPEG</a> with WASM in order to use it in the web, but while it worked, the performance just wasnâ€™t there yet.</p>

<p>So, I decided to build this using a canvas based method. The way it works is that a video elementâ€™s frame is drawn onto a canvas. This gives us flexiblilty in what we render as a GIF and should enable us to resize, move, edit or rotate (all of which still has to be implemented tho).</p>

<p>That canvas is then taken frame-by-frame and rendered as a GIF by <a href="https://jnordberg.github.io/gif.js/">GIF.js</a> which can then be exported.</p>
:ET